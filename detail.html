<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<style>

	.chart rect {
	}

	.chart text {
	  fill: white;
	  font: 10px sans-serif;
	  text-anchor: end;
	}

	</style>
</head>
<body>


<svg class="chart"></svg>

 
<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script>

/**
 * Produce JSON-style voting data from the XML document provided by Government of Canada.
 * @param {XML} dataXml
 * @return {Array} dataJson
 */
function voteJsonFromVoteXml(dataXML) {
	var allVotes = [];
	$(dataXML).find('Vote').each(function(){
		// var sponsor = $(this).find('Sponsor').text();
		// var decision = $(this).find('Decision').text();
		// var bill = $(this).find('RelatedBill').attr('number');
	    $(this).find('Participant').each(function(){
	        allVotes.push({
	        	name: $(this).find("Name").text(),
	            first: $(this).find("FirstName").text(),
	            last: $(this).find("LastName").text(),
	            constituency: $(this).find("Constituency").text(),
	            province: $(this).find("Province").text(),
	            provinceCode: $(this).find("Province").attr('code'),
	            party: $(this).find("Party").text(),
	            yea: Number($(this).find("RecordedVote").find("Yea").text()),
	            nay: Number($(this).find("RecordedVote").find("Nay").text()),
	            paired: Number($(this).find("RecordedVote").find("Paired").text()),
	            url: '',
	        });
	    });
	});
	return allVotes;
	// [
	// 	  {party: 'NDP', yea: 30, nay: 0},
	// 	  {party: 'Liberal', yea: 0, nay: 60},
	//    ...
	// ]
}

$( document ).ready(function() {

	$.ajax({
	    type : 'GET',
	    url : 'data/parl41_sess2_vote2.xml',
	    success : function(dataXML){
	    	data = voteJsonFromVoteXml(dataXML);

			// TODO put an example json here
			var partyVotes = data
				.reduce(function(prev, cur, ix, array) {
					var foo = prev;
					foo[cur.party] = foo[cur.party] || { yea:0, nay:0 };
					foo[cur.party]['yea'] += cur.yea;
					foo[cur.party]['nay'] += cur.nay;
					return foo;
				}, {});

			function appendParliamentRatios(parliament) {
				var totalSeats = 0;
				for (party in parliament) {
					totalSeats += parliament[party]['seats'];
				}
				for (party in parliament) {
					parliament[party]['influence'] = parliament[party]['seats'] / totalSeats;
				}
				return parliament;
			}

			var parliamentCompositionReal = {
				'Bloc Québécois': {seats: 4},
				'Conservative': {seats: 162},
				'Conservative Independent': {seats: 0},
				'Green Party': {seats: 2},
				'Independent': {seats: 7},
				'Liberal': {seats: 36},
				'NDP': {seats: 95}
			};
			appendParliamentRatios(parliamentCompositionReal);

			var parliamentCompositionFake = {
				'Bloc Québécois': {seats: 6},
				'Conservative': {seats: 13900},
				'Conservative Independent': {seats: 8},
				'Green Party': {seats: 8},
				'Independent': {seats: 14},
				'Liberal': {seats: 44},
				'NDP': {seats: 1008}
			};
			appendParliamentRatios(parliamentCompositionFake);

			// TODO flatten the array because all values are scaled the same way.
			// wait, maybe we can't flatten the array? things are still scaled based on party.

			// Realize that the members who participate in any given vote effective
			// make up an instance of parliament. So you can apply the same treatment to the
			// effective parliament of a given day as you would to the elected parliament.

			function parliamentFromVotes(votes) {
				var parliament = {};
				for (party in votes) {
					totalVotes = votes[party].yea + votes[party].nay;
					parliament[party] = {seats: totalVotes};
				}
				return parliament;
			}

			var parlForVote = parliamentFromVotes(partyVotes);
			appendParliamentRatios(parlForVote);

			// console.log("actual parl");
			// console.log("----------");
			//console.log(parliamentCompositionReal);
			// console.log("parl composition for vote");
			// console.log("----------");
			//console.log(parlForVote);

			// partySupport = partyInfluence * partyFavour
			// partySupport:   votes in support of a bill, from a given party
			// partyInfluence: [percentage of?] seats occupied by a party (varies between votes)
			// partyFavour:    percentage of party members that support a bill

			// scaleVotes() adjusts the per-party votes to fit the explicitly defined altParliament,
			// also using the implicitly defined altParliament of the voting data.
			function scaleVote(origVote, altParliament) {
				// Calculate membership of the point-in-time parliament based on counted votes
				var actualParliament = parliamentFromVotes(origVote);
				appendParliamentRatios(actualParliament); // TODO: it's really awkward remembering to do this
				var newVote = {};
				// TODO: for..in only works because I'm constructing a trivial object.
				// If it was a better object, I would need to use a better iterator.
				for (party in origVote) {
					var scaleFactor = altParliament[party]['influence'] / actualParliament[party]['influence'];
					newVote[party] = {
						yea: Math.round(origVote[party]['yea'] * scaleFactor),
						nay: Math.round(origVote[party]['nay'] * scaleFactor)
					};
				}
				return newVote;
			}

			function prettyPrintVote(vote) {
				for (party in vote) {
					var yea = vote[party]['yea'];
					var nay = vote[party]['nay'];
					console.log(party+": "+yea+" yay. "+nay+" nay. ("+(yea+nay)+" total)");
				}
			}

			var rescaledVote = scaleVote(partyVotes, parliamentCompositionFake);
			console.log("ACTUAL VOTE");
			console.log("-----------");
			prettyPrintVote(partyVotes);
			console.log("SCALED VOTE");
			console.log("-----------");
			prettyPrintVote(rescaledVote);

			data = rescaledVote;

			// the rendering function must only use aggregate data, and definitely must
			// not try to work with individual votes. our hypothetical vote results only
			// make sense in aggregate.

			// also, it's impossible to use .map and .reduce on a custom object! hm.

			function summarizeVoteOutcome(votesByParty) {
				var yea = 0;
				var nay = 0;
				for (party in votesByParty) {
					yea += votesByParty[party].yea;
					nay += votesByParty[party].nay;
				}
				return [
					{vote: 'yea', count: yea, colour: 'green'},
					{vote: 'nay', count: nay, colour: 'gray'},
				];
			}

			var pieData = summarizeVoteOutcome(rescaledVote);

			var width = 360;
	        var height = 360;
	        var radius = Math.min(width, height) / 2;

			var svg = d3.select('.chart')
			    .attr("width", width)
			    .attr("height", height)
			    .append('g')
				.attr('transform', 'translate(' + (width / 2) + ',' + (height / 2) + ')');

			var arc = d3.svg.arc()
				.outerRadius(radius);

	        var pie = d3.layout.pie()
				.value(function(d) { return d.count; })
				.sort(null);

	        var path = svg.selectAll('path')
				.data(pie(pieData))
				.enter()
				.append('path')
				.attr('d', arc)
				.attr('fill', function f(d,i){return d.data.colour;});

	    },
	    error : function(){
	        //error handler..
	    }
	});

});

</script>




</body>
</html>