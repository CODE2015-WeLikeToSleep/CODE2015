<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<style>

	.chart rect {
	}

	.chart text {
	  fill: white;
	  font: 10px sans-serif;
	  text-anchor: end;
	}

	</style>
</head>
<body>


<svg class="chart"></svg>

 
<script src="https://code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script>

/**
 * Produce JSON-style voting data from the XML document provided by Government of Canada.
 * @param {XML} dataXml
 * @return {Array} dataJson
 */
function voteJsonFromVoteXml(dataXML) {
	var allVotes = [];
	$(dataXML).find('Vote').each(function(){
		// var sponsor = $(this).find('Sponsor').text();
		// var decision = $(this).find('Decision').text();
		// var bill = $(this).find('RelatedBill').attr('number');
	    $(this).find('Participant').each(function(){
	        allVotes.push({
	        	name: $(this).find("Name").text(),
	            first: $(this).find("FirstName").text(),
	            last: $(this).find("LastName").text(),
	            constituency: $(this).find("Constituency").text(),
	            province: $(this).find("Province").text(),
	            provinceCode: $(this).find("Province").attr('code'),
	            party: $(this).find("Party").text(),
	            yea: Number($(this).find("RecordedVote").find("Yea").text()),
	            nay: Number($(this).find("RecordedVote").find("Nay").text()),
	            paired: Number($(this).find("RecordedVote").find("Paired").text()),
	            url: '',
	        });
	    });
	});
	return allVotes;
	// [
	// 	  {party: 'NDP', yea: 30, nay: 0},
	// 	  {party: 'Liberal', yea: 0, nay: 60},
	//    ...
	// ]
}

/**
 * Produce JSON-style voting data from the XML document provided by Government of Canada.
 * Summarize the votes by party, discarding information about specific members. We use this to
 * represent both actual and hypothetical vote results.
 * BIG TODO: add an attribute indicating whether this is a real or hypothetical result
 * @param {Array} allVotes
 * @return {VoteSummary} voteSummary
 */
function summarizeVotesByParty(allVotes) {
	return allVotes
		.reduce(function(prev, cur, ix, array) {
			var foo = prev;
			foo[cur.party] = foo[cur.party] || { yea:0, nay:0 };
			foo[cur.party]['yea'] += cur.yea;
			foo[cur.party]['nay'] += cur.nay;
			return foo;
		}, {});
}

/**
 * Sometimes you just want a vote summary on the console.
 * @param {VoteSummary} voteSummary
 */
function prettyPrintVote(voteSummary) {
	for (party in voteSummary) {
		var yea = voteSummary[party]['yea'];
		var nay = voteSummary[party]['nay'];
		console.log(party+": "+yea+" yay. "+nay+" nay. ("+(yea+nay)+" total)");
	}
}

/**
 * Derive a new per-party voting outcome based on a hypothetical alternate parliament.
 * @param {VoteSummary} origVote
 * @param {Parliament} altParliament
 */
function scaleVote(origVote, altParliament) {
	// Calculate membership of the point-in-time parliament based on counted votes
	var actualParliament = parliamentFromVotes(origVote);
	appendParliamentRatios(actualParliament); // TODO: it's really awkward remembering to do this
	var newVote = {};
	// TODO: for..in only works because I'm constructing a trivial object.
	// If it was a better object, I would need to use a better iterator.
	for (party in origVote) {
		var scaleFactor = altParliament[party]['influence'] / actualParliament[party]['influence'];
		newVote[party] = {
			yea: Math.round(origVote[party]['yea'] * scaleFactor),
			nay: Math.round(origVote[party]['nay'] * scaleFactor)
		};
	}
	return newVote;
}

/**
 * Realize that the members who participate in any given vote effective
 * make up an instance of parliament. So you can apply the same treatment to the
 * effective parliament of a given day as you would to the elected parliament.
 * @param {VoteSummary} voteSummary
 * @return {Parliament} parliament
 */
function parliamentFromVotes(votes) {
	var parliament = {};
	for (party in votes) {
		totalVotes = votes[party].yea + votes[party].nay;
		parliament[party] = {seats: totalVotes};
	}
	return parliament;
}

/**
 * Augment a parliament object with ratio calculations.
 * TODO: make this part of the parliament object. It's awkward right now.
 * @param {Parliament} parliament
 * @return {Parliament} parliament
 */
function appendParliamentRatios(parliament) {
	var totalSeats = 0;
	for (party in parliament) {
		totalSeats += parliament[party]['seats'];
	}
	for (party in parliament) {
		parliament[party]['influence'] = parliament[party]['seats'] / totalSeats;
	}
	return parliament;
}

// Right now, this alternate parliament is completely imaginary.
// TODO: We will derive a hypothetical parliament by applying an alternate electoral
// system to the per-riding elections data (will be obtained elsewhere).
var alternateParliament = {
	'Bloc Québécois': {seats: 6},
	'Conservative': {seats: 139},
	'Conservative Independent': {seats: 8},
	'Green Party': {seats: 8},
	'Independent': {seats: 14},
	'Liberal': {seats: 44},
	'NDP': {seats: 108}
};

$( document ).ready(function() {

	$.ajax({
	    type : 'GET',
	    url : 'data/parl41_sess2_vote2.xml',
	    success : function(dataXML){
	    	var data = voteJsonFromVoteXml(dataXML);
	    	var partyVotes = summarizeVotesByParty(data);
				appendParliamentRatios(alternateParliament);
			var parlForVote = parliamentFromVotes(partyVotes);
				appendParliamentRatios(parlForVote);

			var rescaledVote = scaleVote(partyVotes, alternateParliament);
			console.log("ACTUAL VOTE");
			prettyPrintVote(partyVotes);
			console.log("SCALED VOTE");
			prettyPrintVote(rescaledVote);

			data = rescaledVote;

			// the rendering function must only use aggregate data, and definitely must
			// not try to work with individual votes. our hypothetical vote results only
			// make sense in aggregate.

			// also, it's impossible to use .map and .reduce on a custom object! hm.

			function summarizeVoteOutcome(votesByParty) {
				var yea = 0;
				var nay = 0;
				for (party in votesByParty) {
					yea += votesByParty[party].yea;
					nay += votesByParty[party].nay;
				}
				return [
					{vote: 'yea', count: yea, colour: 'green'},
					{vote: 'nay', count: nay, colour: 'lightgray'},
				];
			}

			var pieData = summarizeVoteOutcome(rescaledVote);

			var width = 360;
	        var height = 360;
	        var radius = Math.min(width, height) / 2;

			var svg = d3.select('.chart')
			    .attr("width", width)
			    .attr("height", height)
			    .append('g')
				.attr('transform', 'translate(' + (width / 2) + ',' + (height / 2) + ')');

			var arc = d3.svg.arc()
				.outerRadius(radius);

	        var pie = d3.layout.pie()
				.value(function(d) { return d.count; })
				.sort(null);

	        var path = svg.selectAll('path')
				.data(pie(pieData))
				.enter()
				.append('path')
				.attr('d', arc)
				.attr('fill', function f(d,i){return d.data.colour;});

	    },
	    error : function(){
	        //error handler..
	    }
	});

});

</script>




</body>
</html>