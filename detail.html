<!DOCTYPE html>
<meta charset="utf-8">
<head>
	<style>

	.chart rect {
	}

	.chart text {
	  fill: white;
	  font: 10px sans-serif;
	  text-anchor: end;
	}

	</style>
</head>
<body>


<svg class="chart"></svg>

 
<script src="https:////code.jquery.com/jquery-1.11.2.min.js"></script>
<script src="http://d3js.org/d3.v3.js"></script>
<script>

$( document ).ready(function() {

	$.ajax({
	    type :"GET",
	    url : 'data/parl41_sess2_vote2.xml',
	    success : function(dataXML){
	    	var data = [];
            $(dataXML).find('Vote').each(function(){
            	var sponsor = $(this).find('Sponsor').text();
            	var decision = $(this).find('Decision').text();
            	var bill = $(this).find('RelatedBill').attr('number');
                $(this).find('Participant').each(function(){
                    var vote = {
                    	name: $(this).find("Name").text(),
	                    first: $(this).find("FirstName").text(),
	                    last: $(this).find("LastName").text(),
	                    constituency: $(this).find("Constituency").text(),
	                    province: $(this).find("Province").text(),
	                    provinceCode: $(this).find("Province").attr('code'),
	                    party: $(this).find("Party").text(),
	                    yea: Number($(this).find("RecordedVote").find("Yea").text()),
	                    nay: Number($(this).find("RecordedVote").find("Nay").text()),
	                    paired: Number($(this).find("RecordedVote").find("Paired").text()),
	                    url: ''
                    };

                    data.push(vote);
                });
            });

			// TODO put an example json here
			var partyVotes = data
				.reduce(function(prev, cur, ix, array) {
					var foo = prev;
					foo[cur.party] = foo[cur.party] || { yea:0, nay:0 };
					foo[cur.party]['yea'] += cur.yea;
					foo[cur.party]['nay'] += cur.nay;
					return foo;
				}, {});

			function appendParliamentRatios(parliament) {
				var totalSeats = 0;
				for (party in parliament) {
					totalSeats += parliament[party]['seats'];
				}
				for (party in parliament) {
					parliament[party]['influence'] = parliament[party]['seats'] / totalSeats;
				}
				return parliament;
			}

			var parliamentCompositionReal = {
				'Bloc Québécois': {seats: 4},
				'Conservative': {seats: 162},
				'Conservative Independent': {seats: 0},
				'Green Party': {seats: 2},
				'Independent': {seats: 7},
				'Liberal': {seats: 36},
				'NDP': {seats: 95}
			};
			appendParliamentRatios(parliamentCompositionReal);

			var parliamentCompositionFake = {
				'Bloc Québécois': {seats: 6},
				'Conservative': {seats: 139},
				'Conservative Independent': {seats: 8},
				'Green Party': {seats: 8},
				'Independent': {seats: 14},
				'Liberal': {seats: 44},
				'NDP': {seats: 108}
			};
			appendParliamentRatios(parliamentCompositionFake);

			// TODO flatten the array because all values are scaled the same way.
			// wait, maybe we can't flatten the array? things are still scaled based on party.

			// Realize that the members who participate in any given vote effective
			// make up an instance of parliament. So you can apply the same treatment to the
			// effective parliament of a given day as you would to the elected parliament.

			function parliamentFromVotes(votes) {
				var parliament = {};
				for (party in votes) {
					totalVotes = votes[party].yea + votes[party].nay;
					parliament[party] = {seats: totalVotes};
				}
				return parliament;
			}

			var parlForVote = parliamentFromVotes(partyVotes);
			appendParliamentRatios(parlForVote);

			// console.log("actual parl");
			// console.log("----------");
			//console.log(parliamentCompositionReal);
			// console.log("parl composition for vote");
			// console.log("----------");
			//console.log(parlForVote);

			// partySupport = partyInfluence * partyFavour
			// partySupport:   votes in support of a bill, from a given party
			// partyInfluence: [percentage of?] seats occupied by a party (varies between votes)
			// partyFavour:    percentage of party members that support a bill

			// scaleVotes() adjusts the per-party votes to fit the explicitly defined altParliament,
			// also using the implicitly defined altParliament of the voting data.
			function scaleVote(origVote, altParliament) {
				// Calculate membership of the point-in-time parliament based on counted votes
				var actualParliament = parliamentFromVotes(origVote);
				appendParliamentRatios(actualParliament); // TODO: it's really awkward remembering to do this
				var newVote = {};
				// TODO: for..in only works because I'm constructing a trivial object.
				// If it was a better object, I would need to use a better iterator.
				for (party in origVote) {
					var scaleFactor = altParliament[party]['influence'] / actualParliament[party]['influence'];
					newVote[party] = {
						yea: Math.round(origVote[party]['yea'] * scaleFactor),
						nay: Math.round(origVote[party]['nay'] * scaleFactor)
					};
				}
				return newVote;
			}

			function prettyPrintVote(vote) {
				for (party in vote) {
					var yea = vote[party]['yea'];
					var nay = vote[party]['nay'];
					console.log(party+": "+yea+" yay. "+nay+" nay. ("+(yea+nay)+" total)");
				}
			}

			var rescaledVote = scaleVote(partyVotes, parliamentCompositionFake);
			console.log("ACTUAL VOTE");
			console.log("-----------");
			prettyPrintVote(partyVotes);
			console.log("SCALED VOTE");
			console.log("-----------");
			prettyPrintVote(rescaledVote);

			data = rescaledVote;


			// function scaleVotes(realVotes, altParliament) {
			// 	// Construct an original parliament based on the voting data.
			// 	var result = {};
			// 	// TODO calculate both totals. They will often not be the same, because
			// 	// not everybody is in attendance.
			// 	var realTotalVotes = realVotes
			// 		.map(function(cur,ix,array){return cur.yea + cur.nay;})
			// 		.reduce(function(prev,cur,ix,array){return prev+cur;});
			// 	var altTotalVotes = altParliament
			// 		.map(function(cur,ix,array){return d.seats;})
			// 		.reduce(function(prev,cur,ix,array){return prev+cur;});
			// 	Object.keys(realVotes).forEach(function(key) {
			// 		value = realVotes[key];
			// 		var realPartyVotes = realVotes[key]['yea'] + realVotes[key]['nay'];
			// 		//var fakePartyVotes = altParliament
			// 		var partyScaleFactor = 
			// 		result[key]['yea'] = realVotes[key]['yea'] * partyScaleFactor;
			// 		result[key]['nay'] = realVotes[key]['nay'] * partyScaleFactor;
			// 	});
			// }

			// var scaledVotes = scaleVotes(partyVotes, alternateParliament1);

			// console.log(scaledVotes);

			// the rendering function must only use aggregate data, and definitely must
			// not try to work with individual votes. our hypothetical vote results only
			// make sense in aggregate.

			// also, it's impossible to use .map and .reduce on a custom object! hm.

			function summarizeVoteOutcome(votesByParty) {
				var yea = 0;
				var nay = 0;
				for (party in votesByParty) {
					yea += votesByParty[party].yea;
					nay += votesByParty[party].nay;
				}
				return [
					{vote: 'yea', count: yea, colour: 'green'},
					{vote: 'nay', count: nay, colour: 'gray'},
				];
			}

			var pieData = summarizeVoteOutcome(rescaledVote);

			var width = 360;
	        var height = 360;
	        var radius = Math.min(width, height) / 2;

			var svg = d3.select('.chart')
			    .attr("width", width)
			    .attr("height", height)
			    .append('g')
				.attr('transform', 'translate(' + (width / 2) + ',' + (height / 2) + ')');

			var arc = d3.svg.arc()
				.outerRadius(radius);

	        var pie = d3.layout.pie()
				.value(function(d) { return d.count; })
				.sort(null);

	        var path = svg.selectAll('path')
				.data(pie(pieData))
				.enter()
				.append('path')
				.attr('d', arc)
				.attr('fill', function f(d,i){return d.data.colour;});

	    },
	    error : function(){
	        //error handler..
	    }
	});

});

</script>




</body>
</html>